/**
 * Defines the client-side behavior of the file list by registering the necessary event handlers 
 * with the elements generated by the fileList template.
 */
function FileList(form, table) {
	if(!form)
		form = 'fileListForm';
	if('string' == typeof form)
		form = document.getElementById(form);
	if(!table)
		table = 'fileListTable';
	if('string' == typeof table)
		table = document.getElementById(table);
	var rows = table.tBodies[0].getElementsByTagName('TR');
	var headerRow = table.tHead.getElementsByTagName('TR')[0];
	var message = document.getElementById('message');
	var folderRows = [];
	for(var i = 0; i < rows.length; i++) {
		var row = rows[i];
		function registerEvents(id) {
			var cells = row.getElementsByTagName('TD');
			cells[0].ondblclick = function () { edit(id, 'name'); };
			cells[3].ondblclick = function () { edit(id, 'comment'); };
			var folder = document.getElementById('folder'+id);
			if(folder) {
				folderRows[id] = i;
				folder.onclick = function () { return toggleRows(id); };
				var folderSpan = document.getElementById('folderSpan'+id);
				folderSpan.onmousedown = function (ev) { return dragAndDrop(id, ev); };
				var selected = document.getElementById('selected'+id);
				selected.onclick = function () { return selectRows(id, this); };
			}
			else {
				var text = document.getElementById('name'+id);
				text.onmousedown = function (ev) { return dragAndDrop(id, ev); };
			}
		}
		registerEvents(row.id);
	}
	
	/** when selecting (checking) a folder, recursively select all children rows */
	function selectRows(id, selected) {
		var i = folderRows[id];
		if(i != null)
			while(++i < rows.length && rows[i].id.indexOf(id + '-') == 0)
				document.getElementById('selected'+rows[i].id).checked = selected.checked;
		return true;
	}
	
	/** Renaming and comment editing management */
	function edit(id, prefix) {
		var newPrefix = 'new'+prefix.substr(0,1).toUpperCase()+prefix.substring(1);
		var text = document.getElementById(prefix+id);
		var input = document.getElementById(newPrefix+id);
		var oldValue = input.value; 
		var selected = document.getElementById('selected'+id);
		function editMode(mode) {
			var buttons = ['delete', 'download', 'refresh', 'newFile', 'upload'];
			for(var i in buttons)
				document.getElementById(buttons[i]).disabled = mode; 
			text.style.display = mode? 'none': 'inline';
			input.disabled = !mode;
			input.style.display = mode? 'inline': 'none';
		}
		editMode(true);
		input.focus();
		input.select();
		
		/** switch off edit mode when text field looses focus */
		input.onblur = function() { editMode(false); }
		
		/** actually edit (rename or edit comment) if the text field value changes */
		input.onchange = function change() { 
			var params = { relpath: selected.value };
			params[newPrefix] = input.value;
			send(params, function (ok) {
				if(ok) {
					text.innerHTML = htmlspecialchars(input.value);
					if(prefix == 'name') { // if renaming..
						var nameIndex = selected.value.lastIndexOf(oldValue);
						var newRelpath = selected.value.substring(0, nameIndex) + input.value;
						var i = folderRows[id]; // adjust children path..
						if(i != null)
							while(++i < rows.length && rows[i].id.indexOf(id + '-') == 0)
								rename(rows[i].id, newRelpath, selected.value.length);
						rename(id, newRelpath);
					}
				}
				else
					input.value = oldValue;
				editMode(false);
			});
		}
	}
	
	/** rename/move an entry given its ID and new relative path */
	function rename(id, newRelpath, length) {
		var selected = document.getElementById('selected'+id);
		selected.value = length? newRelpath + selected.value.substring(length): newRelpath;
		if(folderRows[id] != null)
			document.getElementById('expanded'+id).value = selected.value;
	}
	
	/** define our simplistic AJAX protocol */
	function send(params, callback) {
		var reqParams = [];
		for(var name in params)
			reqParams.push(name + '=' + urlencode(params[name]));
		sendRequest('?' + reqParams.join('&'), function (reqObj) {
			var responseCode = reqObj.responseText.substr(0,2); // 2 first chars = response code
			var responseMsg = reqObj.responseText.substring(2); // remaining = response message
			if(responseCode == 'OK') {
				callback(true);
				message.className = 'noError';
				message.innerHTML = responseMsg;
			}
			else if(responseCode == 'KO') {
				callback(false);
				message.className = 'error';
				message.innerHTML = responseMsg;
			}
			else {
				callback(false);
				message.className = 'error';
				message.innerHTML = 'Invalid server response: '+responseMsg;
			}
		});
	}
	
	/** tree table management */
	function toggleRows(id) {
		var expanded = document.getElementById('expanded'+id);
		var folder = document.getElementById('folder'+id);
		var collapsing = !expanded.disabled;
		
		// Update current element
		expanded.disabled = !expanded.disabled;
		folder.src = 'folder-' + (collapsing? 'closed': 'open') + '.gif';
	
		/** Show or hide descendants recursively (suppose rows are hierarchically ordered) */
		function recurseToggleRows(offset, prefix, collapsing) {
			while(offset < rows.length && rows[offset].id.indexOf(prefix) == 0) {
				var row = rows[offset++];
				row.style.display = collapsing? 'none': document.all? 'block': 'table-row';
				if(folderRows[row.id] != null) {
					var exp = document.getElementById('expanded'+row.id);
					offset = recurseToggleRows(offset, row.id + '-', collapsing || exp.disabled);
				}
			}
			return offset;
		}
		recurseToggleRows(folderRows[id] + 1, id + '-', collapsing);
		return false;
	}
	
	/** drag and drop management */
	function dragAndDrop(id, ev) {
		ev = ev || window.event;
		var row = document.getElementById(id);
		var text = document.getElementById('name'+id);
		var folder = document.getElementById('folder'+id);
		var sourceRelpath = document.getElementById('selected'+id).value;
	
		// create drag object
		var dragObject = document.createElement('DIV');
		if(folder) {
			var newFolder = document.createElement('IMG');
			newFolder.src = folder.src;
			newFolder.className = folder.className;
			dragObject.appendChild(newFolder);
		}
		dragObject.innerHTML += text.innerHTML;
		dragObject.style.visibility = 'hidden';
		
		// calculate mouse offset
		var mouseOffset = mouseCoords(ev);
		var parent = folder? folder: text; do {
			mouseOffset.x -= parent.offsetLeft;
			mouseOffset.y  -= parent.offsetTop;
		}
		while(parent = parent.offsetParent);
	
		/** drop object when mouse released */
		document.onmouseup = function drop(ev) { 
			ev = ev || window.event;
			document.onmousemove = document.onmouseup = null;
			if(dragObject.style.visibility == 'visible') {
				document.body.removeChild(dragObject);
				var mousePos = mouseCoords(ev);
				var target = getDropTarget(mousePos);
				if(target && target.row != row) {
					var hidden1 = document.createElement('INPUT');
					var hidden2 = document.createElement('INPUT');
					hidden1.type = hidden2.type = 'hidden';
					hidden1.name = 'relpath'; hidden1.value = sourceRelpath;
					hidden2.name = 'newRelpath'; hidden2.value = target.relpath;
					form.appendChild(hidden1);
					form.appendChild(hidden2);
					form.submit();
				}
			}
		}

		/** move object */
		var lastTarget;
		document.onmousemove = function drag(ev) {
			ev = ev || window.event;
			var mousePos = mouseCoords(ev);
			dragObject.style.left = ''+(mousePos.x - mouseOffset.x)+'px';
			dragObject.style.top = ''+(mousePos.y - mouseOffset.y)+'px';
			if(dragObject.style.visibility == 'hidden') {
				document.body.appendChild(dragObject);
				dragObject.style.position = 'absolute';
				dragObject.style.visibility = 'visible';
			}
			var target = getDropTarget(mousePos);
			if(lastTarget && lastTarget != target)
				lastTarget.cell.style.backgroundColor = lastTarget.row == headerRow? '#EEE': 'white';
			if(target && target.row != row) {
				if(target.relpath.indexOf(sourceRelpath) != 0) { // cannot move to ourself
					target.cell.style.backgroundColor = '#CCF';
					lastTarget = target;
				}
			}
			return false;
		}
		
		/** determine drop target at given absolute position */
		function getDropTarget(pos) {
			var root = headerRow.getElementsByTagName('TH')[0];
			if(contains(root, pos))
				return {cell:root, row:headerRow, relpath:'.'};
			for(var id in folderRows) {
				var row = rows[folderRows[id]];
				var cell = row.getElementsByTagName('TD')[0];
				if(contains(cell, pos)) {
					var selected = document.getElementById('selected'+id);
					return {cell:cell, row:row, relpath:selected.value};
				}
			}
			return false;
		}
		return false;
	}
}